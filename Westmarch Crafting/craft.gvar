# craft = '0863d26e-1858-4bc6-99d3-f8d82dab6d2a'

using(
  baglib = '4119d62e-6a98-4153-bea9-0a99bb36da2c',
  currency = '7fdffa53-ac7b-4a40-80d8-eef3aba6f32a',
  docstring = '5aec63f9-9fb4-43e2-93fe-6ca0dcb4b24e',
  downtime = '790f2a58-6042-44b9-acc3-d6c50f0704a2',
  fuzzy = '6431690e-ce47-4baa-bb3b-ba751e1a1817', # Owned by Lathaon#6649
  skill_check_mods = 'eff8567d-a5c1-41a1-9b9b-deb396d73aa8',
  tools = '6251e20c-7545-4c63-92af-31e0745f2b0c', # Owned by pixel_ate_it#5728, see also `!tool`
)

_CRAFT_SVAR = 'crafting_config'
_CRAFT_SVAR_DEFAULT_VALUES = {
  'cvar_name': 'crafting',
  'cost_multipliers': {
    'mundane': 0.5,
    'common': 0.5,
    'uncommon': 0.5,
    'rare': 0.5,
    'very rare': 0.5,
    'legendary': 0.5,
  },
  'level_requirements': {
    'mundane': 0,
    'common': 0,
    'uncommon': 6,
    'rare': 12,
    'very rare': 18,
    'legendary': 20,
  },
  'gp_per_workweek': {
    'mundane': 500,
    'common': 200,
    'uncommon': 1000,
    'rare': 3300,
    'very rare': 10000,
    'legendary': 20000,
  },
  'gear_inventory': {
    # '<category>': '<gvar>' | ['<gvar>'],
  },
  'magic_inventory': {
    # '<category>': '<gvar>' | ['<gvar>'],
  },
  'complications': [
    "Rumors swirl that what youâ€™re working on is unstable and a threat to the community.",
    "Your tools are stolen, forcing you to buy new ones.",
    "A local wizard shows keen interest in your work and insists on observing you.",
    "A powerful noble offers a hefty price for your work and is not interested in hearing no for an answer.",
    "A dwarf clan accuses you of stealing its secret lore to fuel your work.",
    "A competitor spreads rumors that your work is shoddy and prone to failure.",
  ],
  'complication_chance': 2,
}
_CRAFT_SVAR_DEFAULT = dump_yaml(_CRAFT_SVAR_DEFAULT_VALUES)
_CRAFT_CVAR_DEFAULT_VALUES = {}

_config_cache = None
_character = character()

def _is_gvar_id(id: str) -> bool:
  """Test if the given string appears to be a gvar. Used when a value might contain either a gvar id or literal values.

  :param id: The string to test.
  :type id: str
  :return: True if the string appears to be a gvar identifier.
  :rtype: bool
  """
  return typeof(id) == 'str' and len(id) == 36 and [char for char in id if not char in '0123456789abcdef-'] == []

def load_config():
  """Returns the current config settings for crafting.

  :return: The config loaded from an svar.
  :rtype: {
    'cvar_name': str
    'cost_multipliers': dict[str: float]
    'level_requirements': dict[str: int]
    'cost_multipliers': dict[str: float]
    'gear_inventory': dict[str: gvar | [gvar]]
    'magic_inventory': dict[str: gvar | [gvar]]
    'complications': [str]
    'complication_chance': float
  }
  """
  if not _config_cache:
    svar_config = load_yaml(get_svar(_CRAFT_SVAR, default=_CRAFT_SVAR_DEFAULT))
    _config_cache = _CRAFT_SVAR_DEFAULT_VALUES | (load_yaml(get_gvar(svar_config)) if _is_gvar_id(svar_config) else svar_config)
  return _config_cache

def _load_cvar():
  """
  :return: parsed cvar contents
  :rtype: {
    'history': list[tuple[float, str]] | None
    'crafting': {
      'name': str
      'category': str
      'quantity': int
      'base_price': int
      'craft_price': int
      'tool_key': int | None
      'workweeks_required': int
      'workweeks_completed': int
      'complication': str | None
    } | None
  }
  """
  config = load_config()
  if cvar_name := config.get('cvar_name'):
    return load_yaml(_character.get_cvar(cvar_name, '{}')) or {}
  else:
    return _CRAFT_CVAR_DEFAULT_VALUES

def _update_cvar(stored_data):
  config = load_config()
  if cvar_name := config.get('cvar_name'):
    yaml = dump_yaml(stored_data)
    # check if we are about to hit the cvar length limit
    while len(yaml) > 10_000 and stored_data.get('history') and len(stored_data.history) > 0:
        stored_data['history'] = stored_data.history[:-1] # drop the oldest item from the history
        yaml = dump_yaml(stored_data)
    _character.set_cvar(cvar_name, yaml)

def _load_item_data(category, adventuring_gear=False):
  config = load_config()
  if category_data := config.get('magic_inventory' if not adventuring_gear else 'gear_inventory', {}).get(category):
    if _is_gvar_id(category_data):
      return load_yaml(get_gvar(category_data))
    elif category_data.all(_is_gvar_id):
      items = []
      for item in category_data:
         items += load_yaml(get_gvar(item))
      return items
    else:
      return category_data
  else:
    return None

def _get_matches_ignoring_punctuation_with_function(search, iterable, function):
  """
  Returns a list of matching values from iterable,
  applying a given function to each item in the iterable to get the string to match with,
  and ignoring punctuation for purposes of partial matching.
  See gvar '6431690e-ce47-4baa-bb3b-ba751e1a1817'

  :arg str search: the string to match against.
  :arg list|generator|tuple iterable: the iterable to search for matching values.
  :arg value->str function: the function to apply to each value in the iterable.
  :return: a list of matching values.
  :rtype: list
  """
  search_lower = search.lower()
  search_no_punctuation = search_lower.translate(fuzzy.NO_PUNCTUATION_TABLE)
  if partial_matches := [
    x
    for x in iterable
    if search_no_punctuation in function(x).lower().translate(fuzzy.NO_PUNCTUATION_TABLE)
  ]:
    if exact_matches := [x for x in partial_matches if search_lower == function(x).lower()]:
      return exact_matches
    else:
      return partial_matches
  else:
    return []

def _magic_item(item_data, quantity=1): # Name,Rarity,Attunement,Value,Source,Text
  config = load_config()
  rarity = item_data[1]
  base_price = item_data[3]
  craft_price = base_price * config.cost_multipliers[rarity]
  workweeks_required = ceil((craft_price * quantity) / float(config.gp_per_workweek[rarity]))

  # 2014 Artificers have Magic Item Adept at level 10
  # > If you craft a magic item with a rarity of common or uncommon, it takes you a quarter of the normal time, and it costs you half as much of the usual gold.
  if _character.csettings.get('version') == '2014' and _character.levels.get('artificer') >= 10 and (rarity == 'common' or rarity == 'uncommon'):
    craft_price = craft_price / 2
    workweeks_required = ceil(workweeks_required / 4.0)

  subclass = _character.get_cvar('subclass')
  # 2014 Scribes Wizards have Master Scrivener at level 10
  # > The gold and time you must spend to make such a scroll are halved if you use your Wizardly Quill.
  if subclass and _character.csettings.get('version') == '2014' and _character.levels.get('wizard') >= 10 and (subclass.get('WizardLevel', '').lower() == "scribes" or subclass.get('subclasses', {}).get('Order of Scribes')) and 'spell scroll' in item_data[0].lower():
    craft_price = craft_price / 2
    workweeks_required = ceil(workweeks_required / 2.0)

  return {
    'name': item_data[0],
    'rarity': rarity,
    'base_price': base_price,
    'craft_price': craft_price,
    'workweeks_required': workweeks_required,
    'min_level': config.level_requirements[rarity],
  }

def _mundane_item(item_data, quantity=1): # name | price | weight? | attributes? | description?
  config = load_config()
  rarity = 'mundane'
  base_price = item_data[1]
  craft_price = float(base_price) * config.cost_multipliers[rarity]
  workweeks_required = ceil((craft_price * quantity) / float(config.gp_per_workweek[rarity]))
  return {
    'name': item_data[0],
    'rarity': 'mundane',
    'base_price': item_data[2],
    'craft_price': craft_price,
    'workweeks_required': workweeks_required,
    'min_level': config.level_requirements['mundane'],
  }

def _complications() -> list[str]:
  config = load_config()
  config_complications = config.get('complications', [])
  if typeof(config_complications) == 'str':
    config_complications = [config_complications]
  complications = []
  for c in config_complications:
    if _is_gvar_id(c):
      complications.extend(load_yaml(get_gvar(c)))
    else:
      complications.append(c)
  return complications

def craft():
  """Advances the current item being crafted.

  :rtype: {
    'success': bool True if the character was able to make progress on crafting an item.
    'message': str | None Set if `success` is false. An explanation of why the character cannot craft.
    'crafting': dict | None The currently in progress item, if any.
    'completed': dict | None The completed item, if any.
    'started': dict | None The newly started item, if any.
  }
  """
  now = time()

  result = {}
  config = load_config()
  # get the craft in progress
  stored_data = _load_cvar()
  if in_progress := stored_data.get('crafting', None):
    if not downtime.status(current_time=now).available:
       return {'success': False, 'message': "Downtime not available."}
    if in_progress.workweeks_completed == 0:
      if _character.coinpurse.total > in_progress.craft_price * in_progress.quantity: # The character can afford the cost
        fee = parse_coins(str(-1 * in_progress.craft_price * in_progress.quantity))
        _character.coinpurse.modify_coins(pp=fee.pp, gp=fee.gp, ep=fee.ep, sp=fee.sp, cp=fee.cp)
        stored_data['history'] = (stored_data.get('history') or []) + [(now, f'started crafting {in_progress.quantity} x {in_progress.name}, paid {craft_price * in_progress.quantity}gp')]
        result['started'] = True
      else:
        return {'success': False, 'message': f"Crafting requires {currency.format_currency(in_progress.craft_price * in_progress.quantity)} but character only has {currency.format_currency(_character.coinpurse.total)}."}
    downtime.use_downtime(current_time=now)
    in_progress['workweeks_completed'] = in_progress.workweeks_completed + 1
    stored_data['history'] = (stored_data.get('history') or []) + [(now, f'spent one workweek crafting {in_progress.quantity} x {in_progress.name}')]
    if not in_progress.get('complication') and (randint(100) < config.get('complication_chance', 0)) and (complication := rand_choice(_complications())):
      stored_data['history'] = (stored_data.get('history') or []) + [(now, f'encountered a complication: {complication}')]
      in_progress['complication'] = complication
    if in_progress.workweeks_completed >= in_progress.workweeks_required: # if complete award item and clear craft
      bags = baglib.load_bags(ch=_character)
      (bag_used, _, bag_error) = baglib.modify_item(bagsLoaded=bags, item=in_progress.name, quantity=in_progress.quantity)
      bag_result = baglib.save_bags(bagsLoaded = bags)
      stored_data['history'] = (stored_data.get('history') or []) + [(now, f'completed {in_progress.quantity} x {in_progress.name}')]
      stored_data['crafting'] = None
      result['completed'] = in_progress
    else:
      stored_data['crafting'] = in_progress
    _update_cvar(stored_data)
  else:
    return {'success': False, 'message': "Nothing in progress."}
  return {'success': True, 'crafting': in_progress} | result

def discard():
  """Abandons the current item being crafted.

  :rtype: {
    'success': bool True if progress was discarded.
    'message': str | None An explanation of why `success` is false.
  }
  """
  now = time()
  stored_data = _load_cvar()
  if stored_data.get('crafting'):
    stored_data['crafting'] = None
    stored_data['history'] = (stored_data.get('history') or []) + [(now, 'discarded progress')]
    _update_cvar(stored_data)
    return {'success': True}
  else:
    return {'success': False, 'message': "No crafting in progress to discard."}

def history() -> list[tuple[float, str]]:
  """Return all log entries in the character's saved history.

  :return: The list of log entries and their timestamps.
  :rtype: list[tuple[float, str]]
  """
  return _load_cvar().get('history') or []

def categories(adventuring_gear=False):
  """Lists the available categories.

  :arg adventuring_gear bool: Return either adventuring gear or magic item categories.

  :return: A list of category names.
  :rtype: list
  """
  config = load_config()
  return config.get('magic_inventory' if not adventuring_gear else 'gear_inventory', {}).keys()

def matching_categories(search_string, adventuring_gear=False):
  """
  :arg search_string str: A category name to match.
  :arg adventuring_gear bool: Search adventuring gear or magic item categories.

  :return: Returns item categories which match the search string
  :rtype: list[string]
  """
  return fuzzy.get_matches_ignoring_punctuation(
    search=search_string,
    iterable=categories(adventuring_gear=adventuring_gear),
  )

def matching_tools(search_string):
  """
  Returns tools whose names match the search string

  :arg search_string str: A tool name to match.

  :return: A `!tool` tool, see `exact_tool()` in `!gvar 6251e20c-7545-4c63-92af-31e0745f2b0c`
  :rtype: {
    key: str
    name: str
    type: str
    abilities: [str]
  }
  """
  return [tools.exact_tool(key) for key in tools.matching_tools(search_string)]

def search(adventuring_gear: bool, category: str, item_query: str):
  """Returns matching craftable items.

  :arg adventuring_gear bool: If the search should cover adventuring gear or magic items.
  :arg category str: The exact category name to search.
  :arg item_query str: A partial item name to match.

  :return: A list of mundane or magic items.
  :rtype: {
    'name': str
    'rarity': str
    'base_price': float
    'craft_price': float
    'workweeks_required': int
    'min_level': int
  }
  """
  item_data = _load_item_data(category, adventuring_gear=adventuring_gear)
  return [(_mundane_item(item) if adventuring_gear else _magic_item(item)) for item in _get_matches_ignoring_punctuation_with_function(
    search=item_query,
    iterable=item_data,
    function=lambda item: item[0]
  )]

def setup(adventuring_gear: bool, category: str, item:dict, tool_key:str | None, quantity:int = 1):
  """Prepare to craft a new item.

  :arg adventuring_gear bool: If the item to craft is adventuring gear or a magic item.
  :arg category str: The exact category name to search.
  :arg item dict: The item to craft.
  :arg tool_key str: The !tool key string of the tool to use.
  :arg quantity int: The quantity of items to craft.

  :return: Crafting data or an error message.
  :rtype: {
    success: bool True if a new item was setup for crafting to begin.
    message: str | None An explanation of why success is false.
    name: str
    rarity: str
    base_price: float
    craft_price: float
    workweeks_required: int
    min_level: int
    adventuring_gear: bool
    category: str
    quantity: int
    tool_key: str
    workweeks_completed: int
  }
  """
  stored_data = _load_cvar()

  if stored_data.get('crafting', None):
    return {'success': False, 'message': "Crafting in progress."}

  config = load_config()

  if _character.levels.total_level < config.level_requirements[item.rarity]:
    return {'success': False, 'message': f"A {item.rarity} item requires level {config.level_requirements[rarity]}."}

  if tool_key and not tools.is_proficient(tool_key):
    return {'success': False, 'message': f"You must be proficient with the tool used in crafting."}
  if tool_key and tools.tool_type_for(tool_key) != 'artisan':
    return {'success': False, 'message': f"Crafting requires an artisan tool or proficiency in the arcana skill."}
  if not tool_key and _character.skills.arcana.prof < 1:
    return {'success': False, 'message': f"Crafting requires an artisan tool or proficiency in the arcana skill."}

  stored_data['crafting'] = item | {
    'adventuring_gear': adventuring_gear,
    'category': category,
    'quantity': quantity,
    'tool_key': tool_key,
    'workweeks_completed': 0,
  }
  _update_cvar(stored_data)
  return {'success': True, 'crafting': stored_data.crafting}

def status():
  """Return any current craft in progress.

  :return: Crafting data or an error message.
  :rtype: {
    success: bool True if a new item was setup for crafting to begin.
    message: str | None An explanation of why success is false.
    name: str
    rarity: str
    base_price: float
    craft_price: float
    workweeks_required: int
    min_level: int
    adventuring_gear: bool
    category: str
    quantity: int
    tool_key: str
    workweeks_completed: int
    complication: str | None
  }
  """
  stored_data = _load_cvar()
  return stored_data.get('crafting', None)

def status_fields():
  """
  Build embed fields to describe the current crafting state.

  :return: A list of fields.
  :rtype: [{title: str, body: str}]
  """
  fields = []
  current_status = status()
  if not current_status:
    fields.append({'title': 'Nothing in progress', 'body': f"Use `{ctx.prefix}craft setup` to start a new crafting project."})
  else:
    fields.append({'title': 'Crafting', 'body': f'{current_status.quantity} x {current_status.name}'})
    fields.append({'title': 'Cost', 'body': f"{current_status.craft_price * current_status.quantity}gp{' (paid)' if current_status.workweeks_completed > 0 else ''}"})
    fields.append({'title': 'Progress', 'body': f"{current_status.workweeks_completed}/{current_status.workweeks_required} workweeks."})
    if complication := current_status.get('complication'):
      fields.append({'title': 'Complication!', 'body': complication})
  return fields
