# context_filters = 'afe10cd1-ae3c-4fad-94cb-f6f89f9060fd'
#
# CONTEXT FILTERS
# ===============
# Permissions for running aliases. Prevent your aliases from
# spamming channels, limit actions to channels where they can
# be audited, make tools available only to users with certain
# roles.
#
# An svar defines rules based on channel, category, or role for
# who can run aliases with a given command prefix. Aliases can
# then check to see if they should run for the user and in the
# location where they were invoked.
#
# CONFIGURATION
# -------------
# Create a `context_filters` svar containing a yaml dump of the following data structure:
#
# ```
# default: 'allow', # allow or deny all participating aliases by default
# rules: {
#   <prefix string>: {                                # an alias/subalias sequence, the rule with the longest chain of space-delimited tokens matching a key will determine if it is available
#     message: <string>                                  # a user friendly message to show when the alias is prohibitted from running
#     filters: [
#       {
#         filter: 'channel'|'role'|'category',        # which context attribute to filter on
#         action: 'allow'|'deny',                     # does this rule allow or deny access to the alias
#         match: [<channel, role, or category id>],   # a name, id, or array of names or ids to test the filter subject against
#         display: 'channel, role, or category name'  # a user friendly name for this filter's subject(s), provides a more helpful explanation than channel/role ids
#       },
#       ...                                           # multiple filters under the same key are applied in order, with later filters able to override earlier ones
#     ]
#   }
# }
# ```
#
# USE
# ---
# Add a check to any participating alias to see if it should run.
#
# ```
# <drac2>
# using(
#   context_filters = 'afe10cd1-ae3c-4fad-94cb-f6f89f9060fd',
# )
#
# COMMAND = f"{ctx.alias} subalias"
# USAGE = f"{ctx.prefix}{COMMAND} [-type \"query\"] [-item \"query\"]"
#
# (valid, reason) = context_filters.validate(key=COMMAND)
# if not valid:
#   return f'embed -title "⛔️ Invalid command!" -desc "`{COMMAND}`cannot run, reason: {reason}"'
#
# return f'embed -title "normal things" -desc "doing stuff"'
# </drac2>
# ```
#
# Alternately
#
# ```
# <drac2>
# using(
#   context_filters = 'afe10cd1-ae3c-4fad-94cb-f6f89f9060fd',
#   embeds = '72fea181-ba03-4cb4-8edf-1f3bc5a49578',
# )
#
# if filter_embed := context_filters.filter_embed():
#   return embeds.get_output(embed=filter_embed)
#
# return f'embed -title "normal things" -desc "doing stuff"'
# ```
#
# EXAMPLES
# --------
# ```
# default: allow                  # anyone can run an alias, as normal
# rules:
#   shop:
#     filters:
#       - filter: role              # everyone is prohibitted from running any alias command beginning with 'shop'
#         action: deny
#         match: 1234567890
#         display: '@everyone'
#       - filter: category          # unless they are running it in the 'shopping' category
#         action: allow
#         match: 1234567890
#         display: '#shopping'
#       - filter: role              # or have the Dragonspeaker role, in which case they can run the command anywhere
#         action: allow
#         match: Dragonspeaker
#         display: Dragonspeakers
#   shop reroll:
#     filters:
#       - filter: role
#         action: deny
#         match: 1234567890
#         display: '@everyone'
#       - filter: role              # only Dragonspeakers can run this command
#         action: allow
#         match: Dragonspeaker
#         display: Dragonspeakers
#   shop list:                    # noisy commands are prohibited in these specific channels
#     filters:
#       - filter: channel
#         action: deny
#         match: [1234567890, 9876543210]
#         display: 'transaction channels'
# ```
# NOTE:
# - Only one set of rules is applied to any given alias. A command that matches `shop list` will
# not be subject to any of the filter rules under `shop`.
# - Exact matches are not required. A command will use the longest matching rule.
# `shop history` would match the `shop` rule while `shop list all` would match `shop list`.
# - Rule keys are split on whitespace; `shopping` would not match the `shop` rules.

SETTINGS_VAR = 'context_filters'
_DEFAULT_CONFIG = {'default': 'allow', 'rules': {}}

def _should_allow(action:str) -> bool|None:
  """Convert 'allow'/'deny' strings into a tribool.

  :param action: the config string
  :type action: str
  :return: True if allow, False if deny, None if other
  :rtype: bool|None
  """
  match action.lower():
    case 'allow':
      return True
    case 'deny':
      return False
    case _:
      return None

def _reason_for(key:str, filter:dict) -> str:
  """Construct a summary of a filter rule.

  :param key: the key used to match against the rule
  :type key: str
  :param filter: the rule
  :type filter: dict
  :return: a string describing how the filter matched the key
  :rtype: str
  """
  match(filter.get('filter').lower(), filter.get('action').lower(), filter.get('display')):
    case ('channel', 'allow', display):
      return f"`{key}` is only available in {display}"
    case ('channel', 'deny', display):
      return f"`{key}` is not available in {display}"
    case ('role', 'allow', display):
      return f"`{key}` is only available to {display}"
    case ('role', 'deny', display):
      return f"`{key}` is not available to {display}"
    case ('category', 'allow', display):
      return f"`{key}` is only available in {display}"
    case ('category', 'deny', display):
      return f"`{key}` is not available in {display}"

def _matches(filter:dict, context:AliasContext) -> bool:
  """Test if a filter rule applies to a given context.

  :param filter: the filter
  :type filter: dict
  :param context: the context
  :type context: AliasContext
  :return: True if the filter matches, False otherwise
  :rtype: bool
  """
  match = filter.get('match', [])
  match_set = set(match) if 'list' in typeof(match).lower() else set([match])
  filter_type = filter.get('filter')
  role_names = {role.name for role in context.author.get_roles()}
  role_ids = {role.id for role in context.author.get_roles()}
  result = (filter_type == 'channel' and ((context.channel.name in match_set) or (context.channel.id in match_set))) or (filter_type == 'channel' and context.channel.parent and ((context.channel.parent.name in match_set) or (context.channel.parent.id in match_set))) or (filter_type == 'role' and ((len(role_names & match_set) > 0) or (len(role_ids & match_set) > 0))) or (filter_type == 'category' and context.channel.category and ((context.channel.category.name in match_set) or (context.channel.category.id in match_set)))
  return result

_config = _DEFAULT_CONFIG | load_yaml(get_svar(SETTINGS_VAR, default={}))

def validate(key:str=ctx.alias, context:AliasContext=ctx, config:dict=_config) -> tuple[bool|None, str|None, str|None]:
  """Checks if a key (typically the current alias) can be run in the current context.

  :param key: an alias name or other key, defaults to ctx.alias
  :type key: str, optional
  :param context: the current context, defaults to ctx
  :type context: AliasContext, optional
  :param config: the rule config to use, defaults to the SETTINGS_VAR svar
  :type config: dict, optional
  :return: A tuple reporting if the key should be available and, if not, an explanation the rule(s) which blocked access and a message to the user.
  :rtype: tuple[bool|None, str|None, str|None]
  """
  response = _should_allow(config.get('default'))
  summary = []
  messages = []

  key_tokens = key.split()
  rule_key_tokens = {rule_key:rule_key.split() for rule_key in config.get('rules', {}).keys()}
  matching_rule_keys = [rule_key for rule_key, rule_tokens in rule_key_tokens.items() if key_tokens[:len(rule_tokens)] == rule_tokens]
  matching_rule_keys.sort(key=lambda x:len(rule_key_tokens[x]), reverse=True)
  if len(matching_rule_keys) > 0:
    rule = config.get('rules', {}).get(matching_rule_keys[0], {})
    for filter in rule.get('filters', []):
      if typeof(filter) == 'str':
        err(f"rule={rule} matching_rule_keys[0]={matching_rule_keys[0]} filter:{filter}")
      if (action_value := _should_allow(filter.get('action', 'allow'))) is not None:
        if _matches(filter=filter, context=context):
          response = action_value
      summary.append(_reason_for(key=key, filter=filter))
    if message := rule.get('message'):
      messages.append(message)
  return (response, '\n'.join(summary) if response == False and len(summary) > 0 else None, '\n'.join(messages) if response == False and len(messages) > 0 else None)

def filter_embed(context:AliasContext=ctx, config:dict=_config) -> dict|None:
  (valid, explanation, message) = validate(key=context.alias, context=context, config=config)
  if not valid:
    return {
      'title': '⛔️ Invalid command!',
      'desc': message,
      'fields': [{'title': "Rules", 'body': explanation}],
      'footer': f"{ctx.prefix}{ctx.alias}"
    }
